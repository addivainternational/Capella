package nalabs.handlers;

import se.addiva.nalabs.*;

import java.util.*;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.transaction.RecordingCommand;
import org.eclipse.emf.ecore.*;
import org.eclipse.emf.common.util.EList;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.handlers.HandlerUtil;
import org.polarsys.capella.core.model.handler.helpers.CapellaAdapterHelper;
import org.polarsys.kitalpha.vp.requirements.Requirements.*;
import org.polarsys.kitalpha.vp.requirements.Requirements.Module;
import org.polarsys.kitalpha.vp.requirements.Requirements.Requirement;

public class NalabsHandler extends AbstractHandler {

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		
		// Get Requirements from selection
		IStructuredSelection selection = (IStructuredSelection) HandlerUtil.getCurrentSelection(event);
		Collection<Requirement> requirements = getRequirements(selection);
		
		//IWorkbenchWindow window = HandlerUtil.getActiveWorkbenchWindowChecked(event);

		// Re map Requirements for transfer to NOLABS lib, and analyze
		Collection<se.addiva.nalabs.Requirement> nalabRequirements = analyzeRequirements(requirements);
		
		// Re map results to Capella requirements, updating or adding a NOLABS Attribute
		updateRequirements(requirements, nalabRequirements);
		
		return null;
	}
	
	protected void updateRequirements(Collection<Requirement> requirements, Collection<se.addiva.nalabs.Requirement> nalabRequirements) {

		for(Requirement requirement : requirements) {
			se.addiva.nalabs.Requirement matchingAnalysis = findAnalysisMatch(requirement, nalabRequirements);
			
			if(matchingAnalysis != null) {
				String analysisText = formatNalabsAnalysis(matchingAnalysis);
				updateNalabsAttribute(requirement, analysisText);
			}
		}
	}
	
	private String formatNalabsAnalysis(se.addiva.nalabs.Requirement requirement) {
		String analysisText = String.format(
				"%s: NALABS Analysis (%s)\n\tARI: %f\tCONJ: %d\tVAG: %d\tOPT: %d\tSUB: %d\tREF: %d\tWEK: %d\tIMP: %d\tCON: %d\tIMP2: %d\tREF2: %d",
				requirement.Id,
				LocalDateTime.now().toString(),
                requirement.AriScore,
                requirement.Conjunctions,
                requirement.VaguePhrases,
                requirement.Optionality,
                requirement.Subjectivity,
                requirement.References,
                requirement.Weakness,
                requirement.Imperatives,
                requirement.Continuances,
                requirement.Imperatives2,
                requirement.References2				
				);
		
		return analysisText;
	}
	
	
	private se.addiva.nalabs.Requirement findAnalysisMatch(Requirement requirement, Collection<se.addiva.nalabs.Requirement> nalabRequirements) {
		String id = requirement.getReqIFIdentifier();
		
		return nalabRequirements
			.stream()
			.filter(req -> req.Id.equalsIgnoreCase(id))
			.findFirst()
			.orElse(null);
	}

	protected void updateNalabsAttribute(Requirement requirement, String value) {
		Attribute nalabsAttribute = findAttribute(requirement.getOwnedAttributes(), "NALABS");
		// Set or add NALABS value
		if(nalabsAttribute != null) {
			setNalabsAttributeValue(nalabsAttribute, value);
		} else {
			addNalabsAttribute(requirement, value);
		}		
	}
	
	protected Collection<se.addiva.nalabs.Requirement> analyzeRequirements(Collection<Requirement> requirements) {
		
		List<se.addiva.nalabs.Requirement> nalabsRequirements =
				requirements.stream().map(r -> copyRequirement(r)).collect(Collectors.toList());
		
		RequirementAnalyzer.analyzeRequirements(nalabsRequirements.toArray(new se.addiva.nalabs.Requirement[0]));
		
		return nalabsRequirements;
	}
	
	protected se.addiva.nalabs.Requirement copyRequirement(Requirement source){
		se.addiva.nalabs.Requirement target = new se.addiva.nalabs.Requirement(source.getReqIFIdentifier(), source.getReqIFText());
		return target;
	}

	protected Attribute addNalabsAttribute(Requirement requirement, String value) {
		RequirementType rt = requirement.getRequirementType();
		
		if(rt == null) {
			return null;
		}
		
		AttributeDefinition ad = findAttributeDefinition(rt.getOwnedAttributes(), "NALABS");

		if(ad == null) {
			return null;
		}
		
		RequirementsFactory factory = RequirementsFactory.eINSTANCE;
		StringValueAttribute stringValueAttribute = factory.createStringValueAttribute();

		stringValueAttribute.setDefinition(ad);
		stringValueAttribute.setValue(value);
		
		addRequirementAttribute(requirement, stringValueAttribute);
		return stringValueAttribute;
	}
	
	protected void setNalabsAttributeValue(Attribute attribute, String value) {
		EStructuralFeature attributeValueFeature = attribute.eClass().getEStructuralFeature("value");
		setStructuralFeature(attribute, attributeValueFeature, value);
	}
	

	protected AttributeDefinition findAttributeDefinition(Collection<AttributeDefinition> attributes, String id) {
		for(AttributeDefinition ad : attributes) {
			if(ad.getReqIFIdentifier().equalsIgnoreCase(id)) {
				return ad;
			}
		}
		
		return null;
	}

	protected Attribute findAttribute(Collection<Attribute> attributes, String id) {
		for(Attribute a : attributes) {
			if(a.getDefinition().getReqIFIdentifier().equalsIgnoreCase(id)) {
				return a;
			}
		}
		
		return null;
	}

	protected void addRequirementAttribute(Requirement requirement, Attribute attribute) {
		EditingDomain editingDomain = TransactionUtil.getEditingDomain(requirement);
		if(editingDomain == null) {
			editingDomain = TransactionalEditingDomain.Factory.INSTANCE.createEditingDomain();
		}
		
		editingDomain.getCommandStack().execute(new RecordingCommand((TransactionalEditingDomain) editingDomain) {
	        @Override
	        protected void doExecute() {
	    		requirement.getOwnedAttributes().add(attribute);	        	
	        }
	    });
	}

	protected void setStructuralFeature(EObject object, EStructuralFeature feature, Object value) {
		EditingDomain editingDomain = TransactionUtil.getEditingDomain(object);
		if(editingDomain == null) {
			editingDomain = TransactionalEditingDomain.Factory.INSTANCE.createEditingDomain();
		}
		
		editingDomain.getCommandStack().execute(new RecordingCommand((TransactionalEditingDomain) editingDomain) {
	        @Override
	        protected void doExecute() {
	    		object.eSet(feature, value);
	        }
	    });
	}
	

	/*
	 * Collects Requirements from selection, also getting from Modules if selected. 
	 * */
	protected Collection<Requirement> getRequirements(IStructuredSelection selection){
	    Collection<EObject> objects = CapellaAdapterHelper.resolveSemanticObjects(selection.toList());

		Collection<Requirement> reqs = new ArrayList<Requirement>();
		
		for (EObject object : objects) {
			if (object instanceof Requirement) {
				reqs.add((Requirement)object);
	        }
	        else if(object instanceof Module) {
	        	EList<Requirement> ownedRequirements = ((Module)object).getOwnedRequirements();
	        	reqs.addAll(ownedRequirements);
	        }
		}
		
		return reqs;
	}
}
